Казаков Никита ИТ-8 Лабораторная №5
================================================================================================

Задача 1
Текст задачи:
В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка 
числителя и установка знаменателя. 
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного 
значения. 
Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими 
особенностями: 
• Имеет числитель: целое число 
• Имеет знаменатель: целое число 
• Дробь может быть создана с указанием числителя и знаменателя  
• Может вернуть строковое представление вида “числитель/знаменатель” 
• Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может 
быть отрицательным.  
• Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби 
считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя. 


Алгоритм решения:
1. Создать интерфейс Fraction с методами getDecimalValue(), setNumerator(), setDenominator()
2. Создать класс SimpleFraction, реализующий интерфейс
3. Создать класс CachedFraction, который кэширует вычисления
4. CachedFraction хранит реальную дробь и кэшированное значение
5. При изменении дроби кэш сбрасывается

Тесты:
Ввод: -

Ожидаемый вывод:
Создана дробь: 3/4
Первый вызов
Вычислено значение: 0.75
Результат: 0.75

Второй вызов
Использовано кэшированное значение: 0.75
Результат: 0.75

Изменение дроби
Меняем числитель на 1:
Кэш сброшен
Дробь теперь: 1/4

Вызов после изменения:
Вычислено значение: 0.25
Результат: 0.25

Проверка равенства
1/2 = 2/4 : false
1/2 = 1/2 : true

Отрицательные значения
Дробь: -1/2
Значение: -0.5

Вывод программы:
Создана дробь: 3/4
Первый вызов
Вычислено значение: 0.75
Результат: 0.75

Второй вызов
Использовано кэшированное значение: 0.75
Результат: 0.75

Изменение дроби
Меняем числитель на 1:
Кэш сброшен
Дробь теперь: 1/4

Вызов после изменения:
Вычислено значение: 0.25
Результат: 0.25

Проверка равенства
1/2 = 2/4 : false
1/2 = 1/2 : true

Отрицательные значения
Дробь: -1/2
Значение: -0.5

================================================================================================

Задача 2
Текст задачи:
Количество мяуканий.  
Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4. 
Необходимо таким образом передать кота в указанный метод, что бы после окончания его работы 
узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед вызовом 
метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим 
количество мяуканий на экран. Кота изменять нельзя. 
 
Если раннее в вашем варианте не было Кота, то создайте  
1. сущность Кот, которая описывается следующим образом: 
• Имеет Имя (строка) 
• Для создания необходимо указать имя кота. 
• Может быть приведен к текстовой форме вида: “кот: Имя” 
• Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”, 
вызвать мяуканье можно без параметров. 
2. интерфейс Мяуканье: разработайте метод, который принимает набор объектов способных 
мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со 
следующей сигнатурой: 
public void meow(); 

Алгоритм решения:
1. Создать класс Cat с методом meow()
2. Создать класс CatCounter, который оборачивает кота
3. CatCounter считает вызовы meow() и делегирует вызов реальному коту
4. Передать CatCounter в метод вместо обычного кота

Тесты:
Ввод: -

Ожидаемый вывод: 
Шайтан: мяу!
Шайтан: мяу!
Шайтан: мяу!
Кот мяукал: 3 раз

Вывод программы:
Шайтан: мяу!
Шайтан: мяу!
Шайтан: мяу!
Кот мяукал: 3 раз

================================================================================================

Задача 3
Текст задачи:
Составить программу, которая формирует список L включив в него по одному разу элементы, 
которые входят в один из списков L1 и L2, но в то же время не входит в другой из них. 

Алгоритм решения:
1. Создать два списка L1 и L2
2. Пройти по L1, добавить элементы которых нет в L2
3. Пройти по L2, добавить элементы которых нет в L1
4. Убедиться в уникальности элементов

Тесты:
Ввод: -

Ожидаемый вывод:
Список L1: [1, 2, 3, 4, 5]
Список L2: [4, 5, 6, 7, 8]
Результат L: [1, 2, 3, 6, 7, 8]

Список A: [яблоко, банан, апельсин]
Список B: [банан, киви, груша]
Результат: [яблоко, апельсин, киви, груша]

Вывод программы:
Список L1: [1, 2, 3, 4, 5]
Список L2: [4, 5, 6, 7, 8]
Результат L: [1, 2, 3, 6, 7, 8]

Список A: [яблоко, банан, апельсин]
Список B: [банан, киви, груша]
Результат: [яблоко, апельсин, киви, груша]

================================================================================================

Задача 6
Текст задачи:
Напечатать в обратном порядке элементы непустой очереди L. 

Алгоритм решения:
1. Создать очередь и заполнить элементами
2. Использовать стек для разворота порядка
3. Переложить все элементы из очереди в стек
4. Извлечь элементы из стека - получится обратный порядок

Тесты:
Ввод: -

Ожидаемый вывод: 
Оригинальная очередь: [10, 23, 30, 40, 50]
Очередь в обратном порядке: [50, 40, 30, 23, 10]
Очередь после обработки: [10, 23, 30, 40, 50]

Оригинальная очередь: [яблоко, банан, апельсин]
Очередь в обратном порядке: [апельсин, банан, яблоко]
Очередь после обработки: [яблоко, банан, апельсин]

Очередь пуста!

Вывод программы:
Оригинальная очередь: [10, 23, 30, 40, 50]
Очередь в обратном порядке: [50, 40, 30, 23, 10]
Очередь после обработки: [10, 23, 30, 40, 50]

Оригинальная очередь: [яблоко, банан, апельсин]
Очередь в обратном порядке: [апельсин, банан, яблоко]
Очередь после обработки: [яблоко, банан, апельсин]

Очередь пуста!




